<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Comic Reader</title>
  <style>
    :root {
      --bg: linear-gradient(135deg, #0f172a, #1f2937);
      --panel: rgba(255, 255, 255, 0.08);
      --accent: #f97316;
      --text: #e5e7eb;
      --muted: #94a3b8;
      --shadow: 0 20px 60px rgba(0, 0, 0, 0.35);
      --img-width: 100%;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: "Segoe UI", "Fira Sans", "Helvetica Neue", sans-serif;
      background: var(--bg);
      color: var(--text);
      min-height: 100vh;
      display: flex;
      flex-direction: column;
    }
    main { padding: 12px 14px; width: 100%; max-width: 1280px; margin: 0 auto; flex: 1; }
    .layout { display: flex; gap: 16px; align-items: flex-start; }
    .sidebar {
      width: 260px;
      background: var(--panel);
      border: 1px solid rgba(255, 255, 255, 0.08);
      border-radius: 12px;
      padding: 14px;
      box-shadow: var(--shadow);
      position: sticky;
      top: 16px;
      align-self: flex-start;
      display: flex;
      flex-direction: column;
      gap: 14px;
      max-height: calc(100vh - 32px);
      overflow: auto;
      overscroll-behavior: contain;
    }
    .app-title { font-size: 20px; font-weight: 800; letter-spacing: 0.5px; }
    .side-group { display: flex; flex-direction: column; gap: 8px; }
    .side-label { font-size: 13px; color: var(--muted); font-weight: 600; }
    input[type="text"], input[type="number"], input[type="range"], select {
      width: 100%;
      padding: 8px 10px;
      border-radius: 8px;
      border: 1px solid rgba(255, 255, 255, 0.15);
      background: rgba(255, 255, 255, 0.05);
      color: var(--text);
    }
    .row { display: flex; gap: 8px; align-items: center; }
    .hint { font-size: 12px; color: var(--muted); }
    button {
      background: var(--panel);
      color: var(--text);
      border: 1px solid rgba(255, 255, 255, 0.08);
      padding: 9px 12px;
      border-radius: 10px;
      cursor: pointer;
      transition: all 0.15s ease;
      font-weight: 600;
      letter-spacing: 0.2px;
      width: 100%;
    }
    .with-hotkey { position: relative; padding-right: 32px; }
    .hotkey {
      position: absolute;
      right: 8px;
      bottom: 6px;
      font-size: 11px;
      color: var(--muted);
      pointer-events: none;
    }
    .select-wrap { position: relative; }
    .select-wrap .hotkey { right: 10px; bottom: 8px; }
    .select-wrap select { padding-right: 36px; }
    button:hover { border-color: rgba(249, 115, 22, 0.6); transform: translateY(-1px); }
    button.primary { background: var(--accent); color: #111827; border: none; }
    .controls-grid { display: grid; grid-template-columns: repeat(2, minmax(0, 1fr)); gap: 8px; }
    .content { flex: 1; min-width: 0; }
    .status { color: var(--muted); margin: 8px 0 12px; }
    .grid {
      display: flex;
      flex-direction: column;
      gap: 14px;
    }
    .card {
      background: var(--panel);
      border-radius: 14px;
      overflow: hidden;
      border: 1px solid rgba(255, 255, 255, 0.08);
      box-shadow: var(--shadow);
      display: flex;
      flex-direction: column;
      padding: 8px;
      width: var(--img-width);
      max-width: 100%;
      margin: 0 auto;
    }
    .thumb {
      width: 100%;
      height: auto;
      object-fit: contain;
      background: #0b1222;
      cursor: pointer;
      display: block;
    }
    .caption {
      padding: 6px 2px 2px;
      font-size: 13px;
      color: var(--muted);
      text-align: center;
    }
    .pager { display: flex; gap: 8px; align-items: center; flex-wrap: wrap; }
    .pager span { color: var(--muted); font-weight: 600; }
    .drop-zone {
      border: 1px dashed rgba(255, 255, 255, 0.25);
      border-radius: 12px;
      padding: 12px;
      background: rgba(255, 255, 255, 0.03);
      transition: border-color 0.15s ease, background 0.15s ease;
      cursor: pointer;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    .drop-zone.dragover {
      border-color: rgba(249, 115, 22, 0.8);
      background: rgba(249, 115, 22, 0.08);
    }
    .drop-zone .label {
      font-size: 13px;
      color: var(--muted);
    }
    .drop-zone .folder-name {
      font-weight: 600;
      color: var(--text);
      word-break: break-all;
    }
    /* Modal */
    .modal {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.88);
      display: none;
      align-items: center;
      justify-content: center;
      padding: 0;
      z-index: 10;
    }
    .modal.active { display: flex; }
    .modal-content {
      background: transparent;
      border: none;
      border-radius: 0;
      padding: 0;
      width: 100vw;
      height: 100vh;
      max-width: 100vw;
      max-height: 100vh;
      box-shadow: none;
      display: flex;
      flex-direction: column;
      position: relative;
    }
    .modal-stage {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 2px;
      width: 100%;
      height: 100%;
      padding: 6px;
      background: #0f172a;
      flex: 1;
    }
    .modal-stage img {
      flex: 0 1 auto;
      max-width: 50%;
      height: 100%;
      object-fit: contain;
      background: #0f172a;
      margin: 0 2px;
    }
    .modal-stage.single img {
      max-width: 100%;
      margin: 0;
    }
    .modal-controls {
      position: absolute;
      left: 16px;
      top: 16px;
      display: flex;
      flex-direction: column;
      gap: 8px;
      width: 140px;
      background: rgba(15, 23, 42, 0.65);
      padding: 10px;
      border-radius: 12px;
      border: 1px solid rgba(255, 255, 255, 0.12);
      backdrop-filter: blur(6px);
    }
    .modal-caption { color: var(--muted); font-size: 13px; text-align: left; }
    .empty {
      text-align: center;
      color: var(--muted);
      margin-top: 50px;
    }
    @media (max-width: 640px) {
      .layout { flex-direction: column; }
      .sidebar { width: 100%; position: relative; top: 0; }
      .thumb { height: 200px; }
      .modal-controls { width: auto; right: 16px; left: 16px; flex-direction: row; flex-wrap: wrap; }
    }
  </style>
</head>
<body>
  <main>
    <div class="layout">
      <aside class="sidebar">
        <div class="app-title">Comic Reader</div>
        <div class="side-group">
          <div class="side-label">資料夾路徑</div>
          <div id="folderDropZone" class="drop-zone">
            <div class="row">
              <button class="primary" id="chooseFolder">選擇資料夾</button>
              <input type="file" id="folderInput" webkitdirectory directory multiple hidden />
            </div>
            <div class="label">點擊按鈕或將資料夾拖曳到整個瀏覽器</div>
            <div class="folder-name" id="folderLabel">尚未選擇資料夾</div>
          </div>
          <div class="hint">支援在頁面任意位置拖曳整個資料夾，或點「選擇資料夾」。</div>
        </div>
      <div class="side-group">
        <div class="side-label">瀏覽模式</div>
        <div class="controls-grid">
          <button class="primary with-hotkey" id="startSlide">投影片<span class="hotkey">S</span></button>
          <button class="with-hotkey" id="showAll">全部瀏覽<span class="hotkey">A</span></button>
        </div>
      </div>
      <div class="side-group">
        <div class="side-label">漫畫切換</div>
        <div class="controls-grid">
          <button class="with-hotkey" id="prevBook">上一本<span class="hotkey">B</span></button>
          <button class="with-hotkey" id="nextBook">下一本<span class="hotkey">N</span></button>
        </div>
        <div class="hint" id="bookInfo">共 0 本</div>
      </div>
      <div class="side-group">
        <div class="side-label">投影片張數</div>
        <div class="select-wrap">
          <select id="slideMode">
            <option value="auto" selected>自動 (依圖片寬度)</option>
            <option value="single">固定 1 張</option>
            <option value="double">固定 2 張</option>
          </select>
          <span class="hotkey">3/1/2</span>
        </div>
        <div class="hint">預設自動：橫向頁單張；直向頁併成雙頁。</div>
      </div>
      <div class="side-group">
        <div class="side-label">分頁控制</div>
        <div class="controls-grid">
          <button class="with-hotkey" id="prevPage">上一頁<span class="hotkey">←</span></button>
          <button class="with-hotkey" id="nextPage">下一頁<span class="hotkey">→</span></button>
          </div>
          <div class="row">
            <select id="pageSelect"></select>
          </div>
          <div class="hint" id="pageInfo">第 0 / 0 頁</div>
        </div>
        <div class="side-group">
          <div class="side-label">圖片寬度 <span id="widthValue">100%</span></div>
          <input type="range" id="widthSlider" min="50" max="100" step="5" value="100" />
        </div>
        <div class="side-group">
          <div class="side-label">投影片控制</div>
          <div class="controls-grid">
          <button class="with-hotkey" id="prevSlide">上一張<span class="hotkey">←</span></button>
          <button class="with-hotkey" id="nextSlide">下一張<span class="hotkey">→/Space</span></button>
          </div>
          <button class="with-hotkey" id="closeModal">關閉投影片<span class="hotkey">Esc</span></button>
          <div class="hint" id="sidebarCaption">尚未開始</div>
        </div>
      </aside>
      <section class="content">
        <div class="status" id="status">請先選擇資料夾</div>
        <div class="grid" id="grid"></div>
        <div class="empty" id="empty" style="display:none;">No images found.</div>
      </section>
    </div>
  </main>

  <div class="modal" id="modal">
      <div class="modal-content">
        <div class="modal-controls">
          <button class="with-hotkey" id="prevSlideModal">上一張<span class="hotkey">←</span></button>
          <button class="with-hotkey" id="nextSlideModal">下一張<span class="hotkey">→/Space</span></button>
          <button class="with-hotkey" id="prevBookModal">上一本<span class="hotkey">B</span></button>
          <button class="with-hotkey" id="nextBookModal">下一本<span class="hotkey">N</span></button>
          <button class="with-hotkey" id="closeModalModal">關閉<span class="hotkey">Esc</span></button>
          <label class="side-label" style="margin-top:4px;">投影片張數</label>
          <div class="select-wrap">
            <select id="modalSlideMode">
              <option value="auto" selected>自動 (依圖片寬度)</option>
              <option value="single">固定 1 張</option>
              <option value="double">固定 2 張</option>
            </select>
            <span class="hotkey">`/1/2</span>
          </div>
          <div class="modal-caption" id="modalCaption">尚未開始</div>
        </div>
        <div class="modal-stage" id="modalStage"></div>
      </div>
  </div>

  <script>
    const gridEl = document.getElementById("grid");
    const pageInfoEl = document.getElementById("pageInfo");
    const statusEl = document.getElementById("status");
    const emptyEl = document.getElementById("empty");
    const modalEl = document.getElementById("modal");
    const modalStage = document.getElementById("modalStage");
    const modalCaption = document.getElementById("modalCaption");
    const modalControls = document.querySelector(".modal-controls");
    const sidebarCaption = document.getElementById("sidebarCaption");
    const folderInput = document.getElementById("folderInput");
    const folderDropZone = document.getElementById("folderDropZone");
    const folderLabel = document.getElementById("folderLabel");
    const folderPickerBtn = document.getElementById("chooseFolder");
    const pageSelect = document.getElementById("pageSelect");
    const widthSlider = document.getElementById("widthSlider");
    const widthValue = document.getElementById("widthValue");
    const slideModeSelect = document.getElementById("slideMode");
    const modalSlideModeSelect = document.getElementById("modalSlideMode");
    const bookInfoEl = document.getElementById("bookInfo");
    const prevBookBtn = document.getElementById("prevBook");
    const nextBookBtn = document.getElementById("nextBook");
    const prevBookModalBtn = document.getElementById("prevBookModal");
    const nextBookModalBtn = document.getElementById("nextBookModal");
    const PAGE_SIZE = 20;
    let images = [];
    const localObjectUrls = [];
    let currentPage = 1;
    let lastSlideIndex = 0;
    let slideMode = "auto";
    let slides = []; // [{ start: number, count: number }]
    let slidePointer = 0; // index inside slides
    const imageMeta = [];
    const metaPromises = [];
    let books = []; // [{ name: string, items: { name, src }[] }]
    let currentBookIndex = 0;

    function isFileDrag(event) {
      const dt = event && event.dataTransfer;
      return !!dt && Array.from(dt.types || []).includes("Files");
    }

    folderPickerBtn.addEventListener("click", () => folderInput.click());
    folderInput.addEventListener("change", () => {
      if (folderInput.files && folderInput.files.length > 0) {
        handleLocalFiles(folderInput.files, "選擇資料夾");
      }
      folderInput.value = "";
    });
    folderDropZone.addEventListener("dragover", (e) => {
      if (!isFileDrag(e)) return;
      e.preventDefault();
      e.dataTransfer.dropEffect = "copy";
      folderDropZone.classList.add("dragover");
    });
    folderDropZone.addEventListener("dragleave", () => folderDropZone.classList.remove("dragover"));
    folderDropZone.addEventListener("drop", (e) => handleDropEvent(e, "拖曳資料夾"));
    pageSelect.addEventListener("change", onSelectPage);
    widthSlider.addEventListener("input", () => setWidth(widthSlider.value));
    slideModeSelect.addEventListener("change", () => applySlideMode(slideModeSelect.value));
    modalSlideModeSelect.addEventListener("change", () => applySlideMode(modalSlideModeSelect.value));
    document.getElementById("prevPage").addEventListener("click", () => changePage(-1));
    document.getElementById("nextPage").addEventListener("click", () => changePage(1));
    document.getElementById("startSlide").addEventListener("click", () => startSlideshow());
    document.getElementById("showAll").addEventListener("click", () => renderPage(currentPage));
    document.getElementById("prevSlide").addEventListener("click", () => moveSlide(-1));
    document.getElementById("nextSlide").addEventListener("click", () => moveSlide(1));
    document.getElementById("closeModal").addEventListener("click", closeModal);
    document.getElementById("prevSlideModal").addEventListener("click", () => moveSlide(-1));
    document.getElementById("nextSlideModal").addEventListener("click", () => moveSlide(1));
    document.getElementById("closeModalModal").addEventListener("click", closeModal);
    modalEl.addEventListener("click", (e) => {
      if (modalControls && modalControls.contains(e.target)) return;
      const clickedImg = e.target.closest("#modalStage img");
      if (!clickedImg) {
        closeModal();
        return;
      }
      if (clickedOutsideRenderedStage(e, modalStage)) {
        closeModal();
      }
    });
    document.addEventListener("keydown", (e) => {
      const isFormField = e.target instanceof HTMLElement &&
        ["INPUT", "TEXTAREA", "SELECT"].includes(e.target.tagName);

      if (modalEl.classList.contains("active")) {
        if (e.key === "ArrowRight") moveSlide(1);
        if (e.key === "ArrowLeft") moveSlide(-1);
        if (e.key === " " || e.key === "Spacebar") {
          moveSlide(1);
          e.preventDefault();
        }
        if (e.key === "n" || e.key === "N") {
          moveBook(1);
          e.preventDefault();
        }
        if (e.key === "b" || e.key === "B") {
          moveBook(-1);
          e.preventDefault();
        }
        if (handleSlideModeHotkey(e)) return;
        if (e.key === "Escape") closeModal();
        if (e.key === "a" || e.key === "A") {
          closeModal();
          renderPage(currentPage);
        }
        return;
      }

      if (isFormField) return;
      if (handleSlideModeHotkey(e)) return;
      if (e.key === "s" || e.key === "S") {
        startSlideshow();
        e.preventDefault();
        return;
      }
      if (e.key === "a" || e.key === "A") {
        renderPage(currentPage);
        e.preventDefault();
        return;
      }
      if (e.key === "ArrowRight") {
        changePage(1);
        e.preventDefault();
      }
      if (e.key === "ArrowLeft") {
        changePage(-1);
        e.preventDefault();
      }
      if (e.key === "n" || e.key === "N") {
        moveBook(1);
        e.preventDefault();
      }
      if (e.key === "b" || e.key === "B") {
        moveBook(-1);
        e.preventDefault();
      }
    });
    prevBookBtn.addEventListener("click", () => moveBook(-1));
    nextBookBtn.addEventListener("click", () => moveBook(1));
    prevBookModalBtn.addEventListener("click", (e) => {
      e.stopPropagation();
      moveBook(-1);
    });
    nextBookModalBtn.addEventListener("click", (e) => {
      e.stopPropagation();
      moveBook(1);
    });

    window.addEventListener("dragover", (e) => {
      if (!isFileDrag(e)) return;
      e.preventDefault();
      e.dataTransfer.dropEffect = "copy";
      folderDropZone.classList.add("dragover");
    });
    window.addEventListener("dragleave", (e) => {
      if (!isFileDrag(e)) return;
      folderDropZone.classList.remove("dragover");
    });
    window.addEventListener("drop", (e) => handleDropEvent(e, "拖曳資料夾（全畫面）"));

    async function loadImagesFromServer() {
      try {
        const res = await fetch("/api/images");
        const data = await res.json();
        const names = data.images || [];
        cleanupLocalUrls();
        images = names.map((name) => ({
          name,
          src: `/images/${encodeURIComponent(name)}`,
        }));
        books = [{ name: "伺服器資料夾", items: images }];
        currentBookIndex = 0;
        resetSlides();
        if (!images.length) {
          statusEl.textContent = "請先選擇資料夾";
          emptyEl.style.display = "block";
          updateBookControls();
          return;
        }
        emptyEl.style.display = "none";
        statusEl.textContent = `共 ${images.length} 張，分頁顯示，每頁 ${PAGE_SIZE} 張`;
        folderLabel.textContent = "使用伺服器端資料夾";
        updateBookControls();
        renderPage(1);
      } catch (err) {
        statusEl.textContent = "Failed to load images.";
        console.error(err);
      }
    }

    function renderPage(page = 1) {
      currentPage = page;
      const start = (page - 1) * PAGE_SIZE;
      const slice = images.slice(start, start + PAGE_SIZE);

      gridEl.innerHTML = "";
      slice.forEach((name, idx) => {
        const item = typeof name === "string" ? { name, src: `/images/${encodeURIComponent(name)}` } : name;
        const card = document.createElement("div");
        card.className = "card";

        const img = document.createElement("img");
        img.className = "thumb";
        img.src = item.src;
        img.alt = item.name;
        img.loading = "lazy";
        img.addEventListener("click", () => startSlideshow(start + idx));

        const cap = document.createElement("div");
        cap.className = "caption";
        cap.textContent = item.name;

        card.appendChild(img);
        card.appendChild(cap);
        gridEl.appendChild(card);
      });

      const totalPages = Math.max(1, Math.ceil(images.length / PAGE_SIZE));
      pageInfoEl.textContent = `第 ${page} / ${totalPages} 頁`;
      document.getElementById("prevPage").disabled = page <= 1;
      document.getElementById("nextPage").disabled = page >= totalPages;
      updatePageSelect(totalPages);
      pageSelect.value = String(page);
    }

    function changePage(delta) {
      const next = currentPage + delta;
      const totalPages = Math.max(1, Math.ceil(images.length / PAGE_SIZE));
      if (next < 1 || next > totalPages) return;
      renderPage(next);
    }

    function updatePageSelect(totalPages) {
      if (!pageSelect) return;
      const frag = document.createDocumentFragment();
      for (let i = 1; i <= totalPages; i++) {
        const opt = document.createElement("option");
        opt.value = String(i);
        opt.textContent = `第 ${i} 頁`;
        frag.appendChild(opt);
      }
      pageSelect.innerHTML = "";
      pageSelect.appendChild(frag);
    }

    function onSelectPage() {
      const totalPages = Math.max(1, Math.ceil(images.length / PAGE_SIZE));
      const target = parseInt(pageSelect.value, 10);
      if (!Number.isFinite(target)) return;
      const page = Math.min(Math.max(target, 1), totalPages);
      renderPage(page);
    }

    function setWidth(val) {
      // Snap to the nearest 5% so widths are 100%, 95%, 90%, ...
      const num = Number(val);
      const clamped = Math.min(100, Math.max(50, Number.isFinite(num) ? num : 100));
      const snapped = Math.round(clamped / 5) * 5;
      widthSlider.value = snapped;
      document.documentElement.style.setProperty("--img-width", `${snapped}%`);
      widthValue.textContent = `${snapped}%`;
    }

    function handleSlideModeHotkey(event) {
      const key = event.key;
      if (key === "1") {
        applySlideMode("single");
        event.preventDefault();
        return true;
      }
      if (key === "2") {
        applySlideMode("double");
        event.preventDefault();
        return true;
      }
      if (key === "3") {
        applySlideMode("auto");
        event.preventDefault();
        return true;
      }
      return false;
    }

    function syncSlideModeSelectors() {
      if (slideModeSelect) slideModeSelect.value = slideMode;
      if (modalSlideModeSelect) modalSlideModeSelect.value = slideMode;
    }

    function applySlideMode(mode, targetIndex) {
      slideMode = mode || "auto";
      syncSlideModeSelectors();
      const startIndex = typeof targetIndex === "number" ? targetIndex : (lastSlideIndex || currentPageStartIndex());
      return rebuildSlides(startIndex).then(() => {
        if (modalEl.classList.contains("active")) updateSlide();
      });
    }

    function currentPageStartIndex() {
      return (currentPage - 1) * PAGE_SIZE;
    }

    function pageForIndex(idx) {
      return Math.floor(idx / PAGE_SIZE) + 1;
    }

    async function startSlideshow(index) {
      if (!images.length) return;
      const pageStart = currentPageStartIndex();
      let target = typeof index === "number" ? index : pageStart;
      const pageEnd = pageStart + PAGE_SIZE;
      if (typeof index !== "number" && lastSlideIndex >= pageStart && lastSlideIndex < pageEnd) {
        target = lastSlideIndex;
      }
      await rebuildSlides(target);
      modalEl.classList.add("active");
      updateSlide();
    }

    function moveSlide(delta) {
      if (!images.length) return;

      const performMove = () => {
        if (!slides.length) return;
        slidePointer = (slidePointer + delta + slides.length) % slides.length;
        updateSlide();
      };

      if (!slides.length) {
        rebuildSlides(lastSlideIndex || currentPageStartIndex()).then(performMove);
        return;
      }

      performMove();
    }

    function updateSlide() {
      if (!slides.length) return;
      const slide = slides[slidePointer] || { start: 0, count: 1 };
      const indices = [];
      for (let i = 0; i < slide.count && slide.start + i < images.length; i++) {
        indices.push(slide.start + i);
      }
      lastSlideIndex = slide.start;
      renderSlideImages(indices);
      const first = indices[0];
      const last = indices[indices.length - 1];
      const captionText =
        indices.length === 2
          ? `${first + 1}-${last + 1} / ${images.length} - ${images[first].name} & ${images[last].name}`
          : `${first + 1} / ${images.length} - ${images[first].name}`;
      const bookLabel = books.length ? `第 ${currentBookIndex + 1}/${books.length} 本 · ` : "";
      const fullCaption = `${bookLabel}${captionText}`;
      modalCaption.textContent = fullCaption;
      sidebarCaption.textContent = fullCaption;
    }

    function closeModal() {
      modalEl.classList.remove("active");
      if (!images.length) return;
      const page = pageForIndex(lastSlideIndex || 0);
      renderPage(page);
    }

    function clickedOutsideRenderedImage(event, imgEl) {
      if (!imgEl) return false;
      const rect = imgEl.getBoundingClientRect();
      const naturalW = imgEl.naturalWidth;
      const naturalH = imgEl.naturalHeight;
      if (!naturalW || !naturalH || !rect.width || !rect.height) return false;

      const scale = Math.min(rect.width / naturalW, rect.height / naturalH);
      const displayW = naturalW * scale;
      const displayH = naturalH * scale;
      const offsetX = (rect.width - displayW) / 2;
      const offsetY = (rect.height - displayH) / 2;

      const x = event.clientX - rect.left;
      const y = event.clientY - rect.top;

      const withinX = x >= offsetX && x <= offsetX + displayW;
      const withinY = y >= offsetY && y <= offsetY + displayH;
      return !(withinX && withinY);
    }

    function clickedOutsideRenderedStage(event, stageEl) {
      if (!stageEl) return true;
      const imgs = Array.from(stageEl.querySelectorAll("img"));
      if (!imgs.length) return true;
      return imgs.every((img) => clickedOutsideRenderedImage(event, img));
    }

    function cleanupLocalUrls() {
      localObjectUrls.splice(0).forEach((url) => URL.revokeObjectURL(url));
    }

    function resetSlides() {
      slides = [];
      slidePointer = 0;
      lastSlideIndex = 0;
      imageMeta.length = 0;
      metaPromises.length = 0;
    }

    function ensureMeta(index) {
      if (imageMeta[index]) return Promise.resolve(imageMeta[index]);
      if (metaPromises[index]) return metaPromises[index];

      const src = images[index]?.src;
      if (!src) return Promise.resolve({ width: 0, height: 0 });

      const promise = new Promise((resolve) => {
        const img = new Image();
        img.onload = () => {
          const meta = { width: img.naturalWidth || 0, height: img.naturalHeight || 0 };
          imageMeta[index] = meta;
          resolve(meta);
        };
        img.onerror = () => {
          const meta = { width: 0, height: 0 };
          imageMeta[index] = meta;
          resolve(meta);
        };
        img.src = src;
      });

      metaPromises[index] = promise;
      return promise;
    }

    function shouldAutoPair(meta) {
      if (!meta) return false;
      const { width, height } = meta;
      if (!width || !height) return false;
      const aspect = width / height;
      // Portrait/narrow pages become double spread, landscape stays single.
      return aspect <= 0.8;
    }

    async function rebuildSlides(targetIndex = 0) {
      slides = [];
      slidePointer = 0;
      if (!images.length) return;

      let i = 0;
      while (i < images.length) {
        let count = 1;
        if (slideMode === "double") {
          count = Math.min(2, images.length - i);
        } else if (slideMode === "single") {
          count = 1;
        } else {
          const meta = await ensureMeta(i);
          const autoPair = shouldAutoPair(meta);
          count = autoPair && i + 1 < images.length ? 2 : 1;
        }
        slides.push({ start: i, count });
        i += count;
      }

      slidePointer = findSlidePointer(targetIndex);
    }

    function findSlidePointer(targetIndex) {
      const found = slides.findIndex(
        (slide) => targetIndex >= slide.start && targetIndex < slide.start + slide.count
      );
      return found >= 0 ? found : 0;
    }

    function renderSlideImages(indices) {
      modalStage.innerHTML = "";
      modalStage.classList.toggle("single", indices.length === 1);
      indices.forEach((idx) => {
        const item = images[idx];
        const img = document.createElement("img");
        img.className = "modal-img";
        img.src = item.src;
        img.alt = item.name;
        modalStage.appendChild(img);
      });
    }

    function deriveFolderName(files) {
      if (!files.length) return "";
      const relPath = files[0].webkitRelativePath || files[0].name;
      const parts = relPath.split("/");
      return parts.length > 1 ? parts[0] : relPath;
    }

    function bookNameFromFile(file, fallbackFolder) {
      const relPath = file.webkitRelativePath || file.name;
      const parts = relPath.split("/");
      return parts.length > 1 ? parts[0] : fallbackFolder || relPath || "未命名";
    }

    function buildBooks(fileList, fallbackFolder) {
      const groups = new Map();
      Array.from(fileList).forEach((file) => {
        const book = bookNameFromFile(file, fallbackFolder);
        if (!groups.has(book)) groups.set(book, []);
        groups.get(book).push(file);
      });

      return Array.from(groups.entries())
        .sort((a, b) => a[0].localeCompare(b[0], undefined, { numeric: true, sensitivity: "base" }))
        .map(([name, files]) => ({ name, files }));
    }

    function mapFilesToImages(fileArray) {
      return fileArray.map((file) => {
        const url = URL.createObjectURL(file);
        localObjectUrls.push(url);
        return {
          name: file.webkitRelativePath || file.name,
          src: url,
        };
      }).sort(sortByName);
    }

    function setActiveBook(index, sourceLabel, defaultFolderName, resumeSlide) {
      if (!books.length) return;
      const total = books.length;
      currentBookIndex = ((index % total) + total) % total;
      const book = books[currentBookIndex];

      resetSlides();
      images = book.items || [];
      const activeName = book.name || defaultFolderName || "已選擇資料夾";
      folderLabel.textContent = activeName;
      statusEl.textContent = `${sourceLabel || "本地資料夾"}：共 ${images.length} 張（${currentBookIndex + 1}/${total} 本）`;
      emptyEl.style.display = images.length ? "none" : "block";
      renderPage(1);
      updateBookControls();

      if (resumeSlide && modalEl.classList.contains("active")) {
        startSlideshow(0);
      }
    }

    function updateBookControls() {
      const total = books.length || 0;
      const current = total ? currentBookIndex + 1 : 0;
      bookInfoEl.textContent = total ? `第 ${current} / ${total} 本` : "共 0 本";
      const disabled = total <= 1;
      prevBookBtn.disabled = disabled;
      nextBookBtn.disabled = disabled;
      if (prevBookModalBtn) prevBookModalBtn.disabled = disabled;
      if (nextBookModalBtn) nextBookModalBtn.disabled = disabled;
    }

    function moveBook(delta) {
      if (!books.length || books.length <= 1) return;
      const resumeSlide = modalEl.classList.contains("active");
      setActiveBook(
        currentBookIndex + delta,
        "本地資料夾",
        books[currentBookIndex]?.name,
        resumeSlide
      );
    }

    function isImageFile(name) {
      return /\.(png|jpe?g)$/i.test(name);
    }

    function sortByName(a, b) {
      return a.name.localeCompare(b.name, undefined, { numeric: true, sensitivity: "base" });
    }

    function handleLocalFiles(fileList, sourceLabel) {
      const resumeSlide = modalEl.classList.contains("active");
      const files = Array.from(fileList || []);
      const imageFiles = files.filter((file) => isImageFile(file.name));
      if (!imageFiles.length) {
        statusEl.textContent = "資料夾裡沒有可用的圖片 (.png/.jpg/.jpeg)";
        emptyEl.style.display = "block";
        books = [];
        currentBookIndex = 0;
        updateBookControls();
        return;
      }

      cleanupLocalUrls();
      const folderName = deriveFolderName(imageFiles);
      const bookGroups = buildBooks(imageFiles, folderName);
      books = bookGroups.map(({ name, files: groupFiles }) => ({
        name,
        items: mapFilesToImages(groupFiles),
      }));
      currentBookIndex = Math.max(
        0,
        books.findIndex((book) => book.name === folderName)
      );
      setActiveBook(currentBookIndex, sourceLabel, folderName, resumeSlide);
    }

    async function handleDropEvent(event, sourceLabel = "拖曳資料夾") {
      if (!isFileDrag(event)) return;
      event.preventDefault();
      event.stopPropagation();
      folderDropZone.classList.remove("dragover");
      const files = await extractFilesFromDataTransfer(event.dataTransfer);
      if (!files.length) {
        statusEl.textContent = "沒有收到資料夾內容，請再試一次";
        return;
      }
      handleLocalFiles(files, sourceLabel);
    }

    function entryToFiles(entry) {
      return new Promise((resolve) => {
        if (entry.isFile) {
          entry.file(
            (file) => {
              const fullPath = entry.fullPath || file.name;
              if (!file.webkitRelativePath && fullPath) {
                Object.defineProperty(file, "webkitRelativePath", {
                  value: fullPath.replace(/^\//, ""),
                  configurable: true,
                });
              }
              resolve([file]);
            },
            () => resolve([])
          );
        } else if (entry.isDirectory) {
          const reader = entry.createReader();
          const entries = [];
          const readEntries = () => {
            reader.readEntries(
              (batch) => {
                if (!batch.length) {
                  Promise.all(entries.map((ent) => entryToFiles(ent))).then((all) =>
                    resolve(all.flat())
                  );
                  return;
                }
                entries.push(...batch);
                readEntries();
              },
              () => resolve([])
            );
          };
          readEntries();
        } else {
          resolve([]);
        }
      });
    }

    async function extractFilesFromDataTransfer(dataTransfer) {
      if (!dataTransfer) return [];
      const items = Array.from(dataTransfer.items || []);
      const entryPromises = items
        .map((item) => (typeof item.webkitGetAsEntry === "function" ? item.webkitGetAsEntry() : null))
        .filter(Boolean)
        .map((entry) => entryToFiles(entry));

      if (entryPromises.length) {
        const nested = await Promise.all(entryPromises);
        return nested.flat();
      }

      return Array.from(dataTransfer.files || []);
    }

    loadImagesFromServer();
    syncSlideModeSelectors();
    setWidth(widthSlider.value);
  </script>
</body>
</html>
