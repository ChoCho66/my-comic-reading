<!-- Layout markup injected by assets/layout.js -->
<main>
    <div class="layout">
      <aside class="sidebar">
        <div class="title-bar">
          <div class="app-title" id="appTitle">Comic Reader</div>
          <div class="collapse lang-collapse" id="langCollapse">
            <button class="with-hotkey" id="toggleLang">語言</button>
            <div class="collapse-panel">
              <button class="book-btn lang-btn" data-lang="zh">繁體中文</button>
              <button class="book-btn lang-btn" data-lang="en">English</button>
            </div>
          </div>
        </div>
        <div class="side-group">
          <div class="side-label" id="folderPathLabel">資料夾路徑</div>
          <div id="folderDropZone" class="drop-zone">
            <div class="row">
              <button class="primary" id="chooseFolder">選擇資料夾</button>
              <input type="file" id="folderInput" webkitdirectory directory multiple hidden />
            </div>
            <div class="label" id="dropHint">點擊按鈕或將資料夾拖曳到整個瀏覽器</div>
            <div class="folder-name" id="folderLabel">尚未選擇資料夾</div>
          </div>
          <div class="hint" id="dropHelp">支援在頁面任意位置拖曳整個資料夾，或點「選擇資料夾」。</div>
        </div>
      <div class="side-group">
        <div class="side-label" id="viewModeLabel">瀏覽模式</div>
        <div class="controls-grid">
          <button class="primary with-hotkey" id="startSlide">投影片<span class="hotkey">S</span></button>
          <button class="with-hotkey" id="showAll">全部瀏覽<span class="hotkey">A</span></button>
        </div>
      </div>
      <div class="side-group">
        <div class="side-label" id="bookSwitchLabel">漫畫切換</div>
        <div class="controls-grid">
          <button class="with-hotkey" id="prevBook">上一本<span class="hotkey">B</span></button>
          <button class="with-hotkey" id="nextBook">下一本<span class="hotkey">N</span></button>
        </div>
        <div class="hint" id="bookInfo">共 0 本</div>
        <div class="collapse open" id="bookCollapse">
          <button class="with-hotkey" id="toggleBookList">選擇漫畫</button>
          <div class="collapse-panel" id="bookList"></div>
        </div>
      </div>
      <div class="side-group">
        <div class="side-label" id="slideModeLabel">投影片張數</div>
        <div class="select-wrap">
          <select id="slideMode">
            <option value="auto" selected>自動 (依圖片寬度)</option>
            <option value="single">固定 1 張</option>
            <option value="double">固定 2 張</option>
            <option value="triple">固定 3 張</option>
          </select>
          <span class="hotkey">4/1/2/3</span>
        </div>
        <div class="hint" id="slideModeHint">預設自動：橫向頁單張；直向頁併成雙頁。</div>
      </div>
        <div class="side-group">
          <div class="side-label" id="paginationLabel">分頁控制</div>
          <div class="controls-grid">
            <button class="with-hotkey" id="prevPage">上一頁<span class="hotkey">←</span></button>
            <button class="with-hotkey" id="nextPage">下一頁<span class="hotkey">→</span></button>
            </div>
          <div class="row">
            <select id="pageSelect"></select>
          </div>
          <div class="hint" id="pageInfo">第 0 / 0 頁</div>
        </div>
        <div class="side-group">
          <div class="side-label"><span id="widthLabelText">圖片寬度</span> <span id="widthValue">100%</span></div>
          <input type="range" id="widthSlider" min="50" max="100" step="5" value="100" />
        </div>
        <div class="side-group">
          <div class="side-label" id="slideControlLabel">投影片控制</div>
          <div class="controls-grid">
          <button class="with-hotkey" id="prevSlide">下一張<span class="hotkey">←/Space</span></button>
          <button class="with-hotkey" id="nextSlide">上一張<span class="hotkey">→</span></button>
          </div>
          <button class="with-hotkey" id="closeModal">關閉投影片<span class="hotkey">Esc</span></button>
          <div class="hint" id="sidebarCaption">尚未開始</div>
        </div>
      </aside>
      <!-- Main gallery content -->
      <section class="content">
        <div class="status" id="status">請先選擇資料夾</div>
        <div class="grid" id="grid"></div>
        <div class="empty" id="empty" style="display:none;">No images found.</div>
      </section>
    </div>
  </main>

  <!-- Fullscreen slideshow modal -->
  <div class="modal" id="modal">
      <div class="modal-content">
        <div class="modal-controls">
          <button class="with-hotkey" id="prevSlideModal">下一張<span class="hotkey">←/Space</span></button>
          <button class="with-hotkey" id="nextSlideModal">上一張<span class="hotkey">→</span></button>
          <button class="with-hotkey" id="prevBookModal">上一本<span class="hotkey">B</span></button>
          <button class="with-hotkey" id="nextBookModal">下一本<span class="hotkey">N</span></button>
          <button class="with-hotkey" id="closeModalModal">關閉<span class="hotkey">Esc</span></button>
          <div class="collapse open" id="bookCollapseModal">
            <button class="with-hotkey" id="toggleBookListModal">選擇漫畫</button>
            <div class="collapse-panel" id="bookListModal"></div>
          </div>
          <label class="side-label" id="modalSlideModeLabel" style="margin-top:4px;">投影片張數</label>
          <div class="select-wrap">
            <select id="modalSlideMode">
              <option value="auto" selected>自動 (依圖片寬度)</option>
              <option value="single">固定 1 張</option>
              <option value="double">固定 2 張</option>
              <option value="triple">固定 3 張</option>
            </select>
            <span class="hotkey">4/1/2/3</span>
          </div>
          <div class="modal-caption" id="modalCaption">尚未開始</div>
        </div>
        <div class="modal-stage" id="modalStage"></div>
        <div class="slide-progress-wrap" id="slideProgressWrap">
          <input type="range" class="slide-progress" id="slideProgress" min="0" max="0" step="1" value="0" />
          <div class="slide-progress-label" id="slideProgressLabel">0 / 0</div>
        </div>
      </div>
  </div>

  <script>
    // NOTE: This inline script mirrors the logic in assets/app.js and is kept here so
    // layout.html can also run standalone. See assets/app.js for more detailed comments.
    const gridEl = document.getElementById("grid");
    const pageInfoEl = document.getElementById("pageInfo");
    const statusEl = document.getElementById("status");
    const emptyEl = document.getElementById("empty");
    const modalEl = document.getElementById("modal");
    const modalStage = document.getElementById("modalStage");
    const modalCaption = document.getElementById("modalCaption");
    const modalControls = document.querySelector(".modal-controls");
    const slideProgressWrap = document.getElementById("slideProgressWrap");
    const slideProgress = document.getElementById("slideProgress");
    const slideProgressLabel = document.getElementById("slideProgressLabel");
    const sidebarCaption = document.getElementById("sidebarCaption");
    const appTitle = document.getElementById("appTitle");
    const langCollapse = document.getElementById("langCollapse");
    const toggleLangBtn = document.getElementById("toggleLang");
    const folderInput = document.getElementById("folderInput");
    const folderDropZone = document.getElementById("folderDropZone");
    const folderLabel = document.getElementById("folderLabel");
    const folderPickerBtn = document.getElementById("chooseFolder");
    const pageSelect = document.getElementById("pageSelect");
    const widthSlider = document.getElementById("widthSlider");
    const widthValue = document.getElementById("widthValue");
    const widthLabelText = document.getElementById("widthLabelText");
    const slideModeSelect = document.getElementById("slideMode");
    const modalSlideModeSelect = document.getElementById("modalSlideMode");
    const folderPathLabel = document.getElementById("folderPathLabel");
    const dropHint = document.getElementById("dropHint");
    const dropHelp = document.getElementById("dropHelp");
    const viewModeLabel = document.getElementById("viewModeLabel");
    const bookSwitchLabel = document.getElementById("bookSwitchLabel");
    const bookInfoEl = document.getElementById("bookInfo");
    const prevBookBtn = document.getElementById("prevBook");
    const nextBookBtn = document.getElementById("nextBook");
    const prevBookModalBtn = document.getElementById("prevBookModal");
    const nextBookModalBtn = document.getElementById("nextBookModal");
    const bookListEl = document.getElementById("bookList");
    const bookListModalEl = document.getElementById("bookListModal");
    const bookCollapseEl = document.getElementById("bookCollapse");
    const bookCollapseModalEl = document.getElementById("bookCollapseModal");
    const toggleBookListBtn = document.getElementById("toggleBookList");
    const toggleBookListModalBtn = document.getElementById("toggleBookListModal");
    const slideModeLabel = document.getElementById("slideModeLabel");
    const slideModeHint = document.getElementById("slideModeHint");
    const paginationLabel = document.getElementById("paginationLabel");
    const slideControlLabel = document.getElementById("slideControlLabel");
    const modalSlideModeLabel = document.getElementById("modalSlideModeLabel");

    const i18n = {
      current: "zh",
      map: {
        zh: {
          code: "zh-Hant",
          langToggle: "語言",
          langNames: { zh: "繁體中文", en: "英文" },
          appTitle: "Comic Reader",
          folderPathLabel: "資料夾路徑",
          chooseFolder: "選擇資料夾",
          dropHint: "點擊按鈕或將資料夾拖曳到整個瀏覽器",
          dropHelp: "支援在頁面任意位置拖曳整個資料夾，或點「選擇資料夾」。",
          folderLabelDefault: "尚未選擇資料夾",
          viewModeLabel: "瀏覽模式",
          startSlide: "投影片",
          showAll: "全部瀏覽",
          comicSwitchLabel: "漫畫切換",
          prevBook: "上一本",
          nextBook: "下一本",
          bookInfo: ({ current, total }) => (total ? `第 ${current} / ${total} 本` : "共 0 本"),
          chooseBook: "選擇漫畫",
          slideModeLabel: "投影片張數",
          slideModeAuto: "自動 (依圖片寬度)",
          slideModeSingle: "固定 1 張",
          slideModeDouble: "固定 2 張",
          slideModeTriple: "固定 3 張",
          slideModeHint: "預設自動：橫向頁單張；直向頁併成雙頁。",
          paginationLabel: "分頁控制",
          prevPage: "上一頁",
          nextPage: "下一頁",
          pageInfo: ({ page, total }) => `第 ${page} / ${total} 頁`,
          pageOption: (page) => `第 ${page} 頁`,
          widthLabel: "圖片寬度",
          slideControlLabel: "投影片控制",
          nextSlide: "下一張",
          prevSlide: "上一張",
          closeModal: "關閉投影片",
          closeModalShort: "關閉",
          idleCaption: "尚未開始",
          statusPickFolder: "請先選擇資料夾",
          empty: "找不到圖片。",
          bookListEmpty: "目前沒有漫畫",
          statusNoImages: "資料夾裡沒有可用的圖片 (.png/.jpg/.jpeg/.webp)",
          statusNoDrop: "沒有收到資料夾內容，請再試一次",
          loadFail: "載入圖片失敗。",
          sourceLocal: "本地資料夾",
          sourceServer: "伺服器資料夾",
          sourceDrop: "拖曳資料夾",
          sourceWindowDrop: "拖曳資料夾（全畫面）",
          sourcePicker: "選擇資料夾",
          statusCount: ({ source, images, bookIndex, bookTotal }) =>
            `${source}：共 ${images} 張（${bookIndex}/${bookTotal} 本）`,
          bookLabel: ({ current, total }) => (total ? `第 ${current}/${total} 本 · ` : ""),
          slideCaptionSingle: ({ index, total, name }) => `${index} / ${total} - ${name}`,
          slideCaptionRange: ({ start, end, total, names }) => `${start}-${end} / ${total} - ${names[0]} & ${names[1]}`,
        },
        en: {
          code: "en",
          langToggle: "Language",
          langNames: { zh: "Traditional Chinese", en: "English" },
          appTitle: "Comic Reader",
          folderPathLabel: "Folder path",
          chooseFolder: "Choose folder",
          dropHint: "Click the button or drop a folder onto the browser",
          dropHelp: "Drop a folder anywhere on the page or click \"Choose folder\".",
          folderLabelDefault: "No folder selected",
          viewModeLabel: "View mode",
          startSlide: "Slideshow",
          showAll: "Show all",
          comicSwitchLabel: "Comic navigation",
          prevBook: "Previous book",
          nextBook: "Next book",
          bookInfo: ({ current, total }) => (total ? `Book ${current} / ${total}` : "0 books"),
          chooseBook: "Choose comic",
          slideModeLabel: "Slides per view",
          slideModeAuto: "Auto (by image width)",
          slideModeSingle: "Single page",
          slideModeDouble: "Double page",
          slideModeTriple: "Triple page",
          slideModeHint: "Auto: portrait pages pair up; landscape stays single.",
          paginationLabel: "Pages",
          prevPage: "Previous page",
          nextPage: "Next page",
          pageInfo: ({ page, total }) => `Page ${page} / ${total}`,
          pageOption: (page) => `Page ${page}`,
          widthLabel: "Image width",
          slideControlLabel: "Slideshow controls",
          nextSlide: "Next slide",
          prevSlide: "Previous slide",
          closeModal: "Close slideshow",
          closeModalShort: "Close",
          idleCaption: "Not started",
          statusPickFolder: "Pick a folder to start",
          empty: "No images found.",
          bookListEmpty: "No comics yet",
          statusNoImages: "No supported images in this folder (.png/.jpg/.jpeg/.webp)",
          statusNoDrop: "No folder contents received, try again",
          loadFail: "Failed to load images.",
          sourceLocal: "Local folder",
          sourceServer: "Server folder",
          sourceDrop: "Drag folder",
          sourceWindowDrop: "Drag folder (full page)",
          sourcePicker: "Choose folder",
          statusCount: ({ source, images, bookIndex, bookTotal }) =>
            `${source}: ${images} images (${bookIndex}/${bookTotal} books)`,
          bookLabel: ({ current, total }) => (total ? `Book ${current}/${total} · ` : ""),
          slideCaptionSingle: ({ index, total, name }) => `${index} / ${total} - ${name}`,
          slideCaptionRange: ({ start, end, total, names }) => `${start}-${end} / ${total} - ${names[0]} & ${names[1]}`,
        },
      },
      t(key, params) {
        const langPack = this.map[this.current] || this.map.zh;
        const value = langPack[key];
        if (typeof value === "function") return value(params || {});
        return value !== undefined ? value : key;
      },
    };

    function setButtonLabel(button, label) {
      if (!button) return;
      const hotkey = button.querySelector(".hotkey");
      button.textContent = label;
      if (hotkey) button.appendChild(hotkey);
    }

    function getSourceLabel(key) {
      const lookup = {
        local: "sourceLocal",
        server: "sourceServer",
        drop: "sourceDrop",
        windowDrop: "sourceWindowDrop",
        picker: "sourcePicker",
      };
      const targetKey = lookup[key] || lookup.local;
      return i18n.t(targetKey);
    }

    function applyLanguageText() {
      const langPack = i18n.map[i18n.current] || i18n.map.zh;
      document.documentElement.lang = langPack.code || "zh-Hant";
      document.title = i18n.t("appTitle");
      if (appTitle) appTitle.textContent = i18n.t("appTitle");
      if (toggleLangBtn) toggleLangBtn.textContent = i18n.t("langToggle");
      document.querySelectorAll(".lang-btn").forEach((btn) => {
        const code = btn.dataset.lang;
        btn.textContent = langPack.langNames?.[code] || code;
      });
      if (folderPathLabel) folderPathLabel.textContent = i18n.t("folderPathLabel");
      if (folderPickerBtn) folderPickerBtn.textContent = i18n.t("chooseFolder");
      if (dropHint) dropHint.textContent = i18n.t("dropHint");
      if (dropHelp) dropHelp.textContent = i18n.t("dropHelp");
      if (!books.length && folderLabel) folderLabel.textContent = i18n.t("folderLabelDefault");
      if (bookSourceKey === "server") {
        lastDefaultFolderName = i18n.t("sourceServer");
      }
      books.forEach((book) => {
        if (book.serverNames) {
          book.name = i18n.t("sourceServer");
        }
      });
      if (books.length && books[currentBookIndex] && folderLabel) {
        folderLabel.textContent =
          books[currentBookIndex].name || lastDefaultFolderName || i18n.t("folderLabelDefault");
      }
      if (viewModeLabel) viewModeLabel.textContent = i18n.t("viewModeLabel");
      setButtonLabel(document.getElementById("startSlide"), i18n.t("startSlide"));
      setButtonLabel(document.getElementById("showAll"), i18n.t("showAll"));
      if (bookSwitchLabel) bookSwitchLabel.textContent = i18n.t("comicSwitchLabel");
      setButtonLabel(prevBookBtn, i18n.t("prevBook"));
      setButtonLabel(nextBookBtn, i18n.t("nextBook"));
      setButtonLabel(prevBookModalBtn, i18n.t("prevBook"));
      setButtonLabel(nextBookModalBtn, i18n.t("nextBook"));
      setButtonLabel(toggleBookListBtn, i18n.t("chooseBook"));
      setButtonLabel(toggleBookListModalBtn, i18n.t("chooseBook"));
      if (slideModeLabel) slideModeLabel.textContent = i18n.t("slideModeLabel");
      if (modalSlideModeLabel) modalSlideModeLabel.textContent = i18n.t("slideModeLabel");
      if (slideModeHint) slideModeHint.textContent = i18n.t("slideModeHint");
      if (paginationLabel) paginationLabel.textContent = i18n.t("paginationLabel");
      setButtonLabel(document.getElementById("prevPage"), i18n.t("prevPage"));
      setButtonLabel(document.getElementById("nextPage"), i18n.t("nextPage"));
      if (slideControlLabel) slideControlLabel.textContent = i18n.t("slideControlLabel");
      setButtonLabel(document.getElementById("prevSlide"), i18n.t("nextSlide"));
      setButtonLabel(document.getElementById("nextSlide"), i18n.t("prevSlide"));
      setButtonLabel(document.getElementById("closeModal"), i18n.t("closeModal"));
      setButtonLabel(document.getElementById("prevSlideModal"), i18n.t("nextSlide"));
      setButtonLabel(document.getElementById("nextSlideModal"), i18n.t("prevSlide"));
      setButtonLabel(document.getElementById("closeModalModal"), i18n.t("closeModalShort"));
      if (widthLabelText) widthLabelText.textContent = i18n.t("widthLabel");
      if (emptyEl) emptyEl.textContent = i18n.t("empty");
      if (!images.length) {
        sidebarCaption.textContent = i18n.t("idleCaption");
        modalCaption.textContent = i18n.t("idleCaption");
      }
      setSlideModeOptionLabels();
      renderPage(currentPage);
      updateBookControls();
      updateStatusText();
      updateSlideProgressBar();
      if (slides.length) {
        updateSlide();
      }
    }

    function setSlideModeOptionLabels() {
      const autoLabel = i18n.t("slideModeAuto");
      const singleLabel = i18n.t("slideModeSingle");
      const doubleLabel = i18n.t("slideModeDouble");
      const tripleLabel = i18n.t("slideModeTriple");
      [slideModeSelect, modalSlideModeSelect].forEach((select) => {
        if (!select) return;
        const autoOpt = select.querySelector('option[value="auto"]');
        const singleOpt = select.querySelector('option[value="single"]');
        const doubleOpt = select.querySelector('option[value="double"]');
        const tripleOpt = select.querySelector('option[value="triple"]');
        if (autoOpt) autoOpt.textContent = autoLabel;
        if (singleOpt) singleOpt.textContent = singleLabel;
        if (doubleOpt) doubleOpt.textContent = doubleLabel;
        if (tripleOpt) tripleOpt.textContent = tripleLabel;
      });
    }

    function setLanguage(lang) {
      i18n.current = lang === "en" ? "en" : "zh";
      if (!books.length) {
        lastDefaultFolderName = i18n.t("folderLabelDefault");
      }
      applyLanguageText();
    }
    const PAGE_SIZE = 20;
    let images = [];
    const localObjectUrls = [];
    let currentPage = 1;
    let lastSlideIndex = 0;
    let slideMode = "auto";
    let slides = []; // [{ start: number, count: number }]
    let slidePointer = 0; // index inside slides
    const imageMeta = [];
    const metaPromises = [];
    let books = []; // [{ name: string, items: { name, src }[] }]
    let currentBookIndex = 0;
    let bookSourceKey = "local";
    let lastDefaultFolderName = i18n.t("folderLabelDefault");
    let statusKey = "statusPickFolder";
    let statusParams = null;

    function isFileDrag(event) {
      const dt = event && event.dataTransfer;
      return !!dt && Array.from(dt.types || []).includes("Files");
    }

    folderPickerBtn.addEventListener("click", () => folderInput.click());
    folderInput.addEventListener("change", () => {
      if (folderInput.files && folderInput.files.length > 0) {
        handleLocalFiles(folderInput.files, "picker");
      }
      folderInput.value = "";
    });
    folderDropZone.addEventListener("dragover", (e) => {
      if (!isFileDrag(e)) return;
      e.preventDefault();
      e.dataTransfer.dropEffect = "copy";
      folderDropZone.classList.add("dragover");
    });
    folderDropZone.addEventListener("dragleave", () => folderDropZone.classList.remove("dragover"));
    folderDropZone.addEventListener("drop", (e) => handleDropEvent(e, "drop"));
    pageSelect.addEventListener("change", onSelectPage);
    widthSlider.addEventListener("input", () => setWidth(widthSlider.value));
    slideModeSelect.addEventListener("change", () => applySlideMode(slideModeSelect.value));
    modalSlideModeSelect.addEventListener("change", () => applySlideMode(modalSlideModeSelect.value));
    document.getElementById("prevPage").addEventListener("click", () => changePage(-1));
    document.getElementById("nextPage").addEventListener("click", () => changePage(1));
    document.getElementById("startSlide").addEventListener("click", () => startSlideshow());
    document.getElementById("showAll").addEventListener("click", () => renderPage(currentPage));
    document.getElementById("prevSlide").addEventListener("click", () => moveSlide(1));
    document.getElementById("nextSlide").addEventListener("click", () => moveSlide(-1));
    document.getElementById("closeModal").addEventListener("click", closeModal);
    document.getElementById("prevSlideModal").addEventListener("click", () => moveSlide(1));
    document.getElementById("nextSlideModal").addEventListener("click", () => moveSlide(-1));
    document.getElementById("closeModalModal").addEventListener("click", closeModal);
    modalEl.addEventListener("click", (e) => {
      if (modalControls && modalControls.contains(e.target)) return;
      if (slideProgressWrap && slideProgressWrap.contains(e.target)) return;
      const clickedImg = e.target.closest("#modalStage img");
      if (!clickedImg) {
        closeModal();
        return;
      }
      if (clickedOutsideRenderedStage(e, modalStage)) {
        closeModal();
      }
    });
    document.addEventListener("keydown", (e) => {
      const isFormField = e.target instanceof HTMLElement &&
        ["INPUT", "TEXTAREA", "SELECT"].includes(e.target.tagName);

      if (modalEl.classList.contains("active")) {
        if (e.key === "ArrowRight") moveSlide(-1);
        if (e.key === "ArrowLeft") moveSlide(1);
        if (e.key === "ArrowUp") {
          moveBook(-1);
          e.preventDefault();
          return;
        }
        if (e.key === "ArrowDown") {
          moveBook(1);
          e.preventDefault();
          return;
        }
        if (e.key === " " || e.key === "Spacebar") {
          moveSlide(1);
          e.preventDefault();
        }
        if (e.key === "0") {
          jumpToSlideIndex(0);
          e.preventDefault();
          return;
        }
        if (e.key === "9") {
          jumpToSlideIndex(images.length - 1);
          e.preventDefault();
          return;
        }
        if (["5", "6", "7", "8"].includes(e.key)) {
          const tenths = Number(e.key) / 10;
          jumpToSlideProgress(tenths);
          e.preventDefault();
          return;
        }
        if (e.key === "n" || e.key === "N") {
          moveBook(1);
          e.preventDefault();
        }
        if (e.key === "b" || e.key === "B") {
          moveBook(-1);
          e.preventDefault();
        }
        if (handleSlideModeHotkey(e)) return;
        if (e.key === "Escape") closeModal();
        if (e.key === "a" || e.key === "A") {
          closeModal();
          renderPage(currentPage);
        }
        return;
      }

      if (isFormField) return;
      if (handleSlideModeHotkey(e)) return;
      if (e.key === "s" || e.key === "S") {
        startSlideshow();
        e.preventDefault();
        return;
      }
      if (e.key === "a" || e.key === "A") {
        renderPage(currentPage);
        e.preventDefault();
        return;
      }
      if (e.key === "ArrowRight") {
        changePage(1);
        e.preventDefault();
      }
      if (e.key === "ArrowLeft") {
        changePage(-1);
        e.preventDefault();
      }
      if (e.key === "n" || e.key === "N") {
        moveBook(1);
        e.preventDefault();
      }
      if (e.key === "b" || e.key === "B") {
        moveBook(-1);
        e.preventDefault();
      }
    });
    prevBookBtn.addEventListener("click", () => moveBook(-1));
    nextBookBtn.addEventListener("click", () => moveBook(1));
    prevBookModalBtn.addEventListener("click", (e) => {
      e.stopPropagation();
      moveBook(-1);
    });
    nextBookModalBtn.addEventListener("click", (e) => {
      e.stopPropagation();
      moveBook(1);
    });
    toggleBookListBtn?.addEventListener("click", () => toggleCollapse(bookCollapseEl));
    toggleBookListModalBtn?.addEventListener("click", (e) => {
      e.stopPropagation();
      toggleCollapse(bookCollapseModalEl);
    });
    slideProgress?.addEventListener("input", () => {
      if (!slideProgress) return;
      const val = Number(slideProgress.value);
      jumpToSlideIndex(val);
    });
    toggleLangBtn?.addEventListener("click", () => toggleCollapse(langCollapse));
    document.querySelectorAll(".lang-btn").forEach((btn) => {
      btn.addEventListener("click", (e) => {
        e.stopPropagation();
        setLanguage(btn.dataset.lang);
        if (langCollapse) langCollapse.classList.remove("open");
      });
    });

    window.addEventListener("dragover", (e) => {
      if (!isFileDrag(e)) return;
      e.preventDefault();
      e.dataTransfer.dropEffect = "copy";
      folderDropZone.classList.add("dragover");
    });
    window.addEventListener("dragleave", (e) => {
      if (!isFileDrag(e)) return;
      folderDropZone.classList.remove("dragover");
    });
    window.addEventListener("drop", (e) => handleDropEvent(e, "windowDrop"));

    async function loadImagesFromServer() {
      try {
        const res = await fetch("/api/images");
        const data = await res.json();
        const names = data.images || [];
        cleanupLocalUrls();
        const serverName = i18n.t("sourceServer");
        books = [{ name: serverName, serverNames: names }];
        currentBookIndex = 0;
        bookSourceKey = "server";
        lastDefaultFolderName = serverName;
        setActiveBook(0, bookSourceKey, lastDefaultFolderName, false);
        if (!names.length) {
          setStatus("statusPickFolder");
          emptyEl.style.display = "block";
        }
      } catch (err) {
        setStatus("loadFail");
        console.error(err);
      }
    }

    function renderPage(page = 1) {
      currentPage = page;
      const start = (page - 1) * PAGE_SIZE;
      const slice = images.slice(start, start + PAGE_SIZE);

      gridEl.innerHTML = "";
      slice.forEach((name, idx) => {
        const item = typeof name === "string" ? { name, src: `/images/${encodeURIComponent(name)}` } : name;
        const card = document.createElement("div");
        card.className = "card";

        const img = document.createElement("img");
        img.className = "thumb";
        img.src = item.src;
        img.alt = item.name;
        img.loading = "lazy";
        img.addEventListener("click", () => startSlideshow(start + idx));

        const cap = document.createElement("div");
        cap.className = "caption";
        cap.textContent = item.name;

        card.appendChild(img);
        card.appendChild(cap);
        gridEl.appendChild(card);
      });

      const totalPages = Math.max(1, Math.ceil(images.length / PAGE_SIZE));
      pageInfoEl.textContent = i18n.t("pageInfo", { page, total: totalPages });
      document.getElementById("prevPage").disabled = page <= 1;
      document.getElementById("nextPage").disabled = page >= totalPages;
      updatePageSelect(totalPages);
      pageSelect.value = String(page);
    }

    function changePage(delta) {
      const next = currentPage + delta;
      const totalPages = Math.max(1, Math.ceil(images.length / PAGE_SIZE));
      if (next < 1 || next > totalPages) return;
      renderPage(next);
    }

    function updatePageSelect(totalPages) {
      if (!pageSelect) return;
      const frag = document.createDocumentFragment();
      for (let i = 1; i <= totalPages; i++) {
        const opt = document.createElement("option");
        opt.value = String(i);
        opt.textContent = i18n.t("pageOption", i);
        frag.appendChild(opt);
      }
      pageSelect.innerHTML = "";
      pageSelect.appendChild(frag);
    }

    function formatStatus(key, params) {
      if (key === "statusCount") {
        const imageTotal = params && typeof params.images === "number" ? params.images : images.length;
        const bookTotal =
          params && typeof params.bookTotal === "number" ? params.bookTotal : books.length || 0;
        const bookIndex =
          params && typeof params.bookIndex === "number" ? params.bookIndex : currentBookIndex + 1;
        const sourceKeyParam = params && params.sourceKey ? params.sourceKey : bookSourceKey;
        const sourceText = getSourceLabel(sourceKeyParam);
        return i18n.t("statusCount", {
          source: sourceText,
          images: imageTotal,
          bookIndex,
          bookTotal,
        });
      }
      return i18n.t(key || "statusPickFolder");
    }

    function setStatus(key, params) {
      statusKey = key;
      statusParams = params || null;
      if (!statusEl) return;
      statusEl.textContent = formatStatus(key, params);
    }

    function updateStatusText() {
      if (!statusEl) return;
      statusEl.textContent = formatStatus(statusKey, statusParams);
    }

    function onSelectPage() {
      const totalPages = Math.max(1, Math.ceil(images.length / PAGE_SIZE));
      const target = parseInt(pageSelect.value, 10);
      if (!Number.isFinite(target)) return;
      const page = Math.min(Math.max(target, 1), totalPages);
      renderPage(page);
    }

    function setWidth(val) {
      // Snap to the nearest 5% so widths are 100%, 95%, 90%, ...
      const num = Number(val);
      const clamped = Math.min(100, Math.max(50, Number.isFinite(num) ? num : 100));
      const snapped = Math.round(clamped / 5) * 5;
      widthSlider.value = snapped;
      document.documentElement.style.setProperty("--img-width", `${snapped}%`);
      widthValue.textContent = `${snapped}%`;
    }

    function handleSlideModeHotkey(event) {
      const key = event.key;
      if (key === "1") {
        applySlideMode("single");
        event.preventDefault();
        return true;
      }
      if (key === "2") {
        applySlideMode("double");
        event.preventDefault();
        return true;
      }
      if (key === "3") {
        applySlideMode("triple");
        event.preventDefault();
        return true;
      }
      if (key === "4") {
        applySlideMode("auto");
        event.preventDefault();
        return true;
      }
      return false;
    }

    function syncSlideModeSelectors() {
      if (slideModeSelect) slideModeSelect.value = slideMode;
      if (modalSlideModeSelect) modalSlideModeSelect.value = slideMode;
    }

    function applySlideMode(mode, targetIndex) {
      slideMode = mode || "auto";
      syncSlideModeSelectors();
      const startIndex = typeof targetIndex === "number" ? targetIndex : (lastSlideIndex || currentPageStartIndex());
      return rebuildSlides(startIndex).then(() => {
        if (modalEl.classList.contains("active")) updateSlide();
      });
    }

    function currentPageStartIndex() {
      return (currentPage - 1) * PAGE_SIZE;
    }

    function pageForIndex(idx) {
      return Math.floor(idx / PAGE_SIZE) + 1;
    }

    async function startSlideshow(index) {
      if (!images.length) return;
      const pageStart = currentPageStartIndex();
      let target = typeof index === "number" ? index : pageStart;
      const pageEnd = pageStart + PAGE_SIZE;
      if (typeof index !== "number" && lastSlideIndex >= pageStart && lastSlideIndex < pageEnd) {
        target = lastSlideIndex;
      }
      await rebuildSlides(target);
      modalEl.classList.add("active");
      updateSlide();
    }

    async function moveSlide(delta) {
      if (!images.length) return;

      if (!slides.length) {
        await rebuildSlides(lastSlideIndex || currentPageStartIndex());
      }
      if (!slides.length) return;

      let nextPointer = slidePointer + delta;

      if (nextPointer >= slides.length) {
        const hasNext = books.length > 1 && currentBookIndex < books.length - 1;
        if (hasNext) {
          const nextBookIdx = currentBookIndex + 1;
          setActiveBook(
            nextBookIdx,
            bookSourceKey,
            books[nextBookIdx]?.name,
            true,
            0
          );
          return;
        }
        nextPointer = slides.length - 1;
      } else if (nextPointer < 0) {
        const hasPrev = books.length > 1 && currentBookIndex > 0;
        if (hasPrev) {
          const prevBookIdx = currentBookIndex - 1;
          const prevBook = books[prevBookIdx];
          const prevCount =
            (prevBook?.files && prevBook.files.length) ||
            (prevBook?.serverNames && prevBook.serverNames.length) ||
            (prevBook?.items && prevBook.items.length) ||
            0;
          const lastIdx = Math.max(0, prevCount - 1);
          setActiveBook(
            prevBookIdx,
            bookSourceKey,
            books[prevBookIdx]?.name,
            true,
            lastIdx
          );
          return;
        }
        nextPointer = 0;
      }

      slidePointer = nextPointer;
      updateSlide();
    }

    async function jumpToSlideIndex(targetIndex) {
      if (!images.length) return;
      const clamped = Math.min(Math.max(0, targetIndex), Math.max(0, images.length - 1));
      await rebuildSlides(clamped);
      if (!slides.length) return;
      slidePointer = findSlidePointer(clamped);
      updateSlide();
    }

    function jumpToSlideProgress(fraction) {
      if (!images.length) return;
      const frac = Math.min(Math.max(fraction, 0), 1);
      const target = Math.round((images.length - 1) * frac);
      jumpToSlideIndex(target);
    }

    function updateSlideProgressBar() {
      if (!slideProgress) return;
      const total = images.length;
      const activeIndex = Math.min(Math.max(lastSlideIndex || 0, 0), Math.max(0, total - 1));
      slideProgress.max = Math.max(0, total - 1);
      slideProgress.value = activeIndex;
      slideProgress.disabled = total <= 1;
      if (slideProgressLabel) {
        slideProgressLabel.textContent = total ? `${activeIndex + 1} / ${total}` : "0 / 0";
      }
      if (slideProgressWrap) {
        slideProgressWrap.style.display = modalEl.classList.contains("active") ? "flex" : "none";
      }
    }

    function updateSlide() {
      if (!slides.length) return;
      const slide = slides[slidePointer] || { start: 0, count: 1 };
      const indices = [];
      for (let i = 0; i < slide.count && slide.start + i < images.length; i++) {
        indices.push(slide.start + i);
      }
      lastSlideIndex = slide.start;
      const displayOrder = indices.length > 1 ? [...indices].reverse() : indices;
      renderSlideImages(displayOrder);
      const first = indices[0];
      const last = indices[indices.length - 1];
      const captionText =
        indices.length === 2
          ? i18n.t("slideCaptionRange", {
              start: first + 1,
              end: last + 1,
              total: images.length,
              names: [images[first].name, images[last].name],
            })
          : i18n.t("slideCaptionSingle", {
              index: first + 1,
              total: images.length,
              name: images[first].name,
            });
      const bookLabel = books.length
        ? i18n.t("bookLabel", { current: currentBookIndex + 1, total: books.length })
        : "";
      const fullCaption = `${bookLabel}${captionText}`;
      modalCaption.textContent = fullCaption;
      sidebarCaption.textContent = fullCaption;
      updateSlideProgressBar();
    }

    function closeModal() {
      modalEl.classList.remove("active");
      if (slideProgressWrap) slideProgressWrap.style.display = "none";
      if (!images.length) return;
      const page = pageForIndex(lastSlideIndex || 0);
      renderPage(page);
    }

    function clickedOutsideRenderedImage(event, imgEl) {
      if (!imgEl) return false;
      const rect = imgEl.getBoundingClientRect();
      const naturalW = imgEl.naturalWidth;
      const naturalH = imgEl.naturalHeight;
      if (!naturalW || !naturalH || !rect.width || !rect.height) return false;

      const scale = Math.min(rect.width / naturalW, rect.height / naturalH);
      const displayW = naturalW * scale;
      const displayH = naturalH * scale;
      const offsetX = (rect.width - displayW) / 2;
      const offsetY = (rect.height - displayH) / 2;

      const x = event.clientX - rect.left;
      const y = event.clientY - rect.top;

      const withinX = x >= offsetX && x <= offsetX + displayW;
      const withinY = y >= offsetY && y <= offsetY + displayH;
      return !(withinX && withinY);
    }

    function clickedOutsideRenderedStage(event, stageEl) {
      if (!stageEl) return true;
      const imgs = Array.from(stageEl.querySelectorAll("img"));
      if (!imgs.length) return true;
      return imgs.every((img) => clickedOutsideRenderedImage(event, img));
    }

    function cleanupLocalUrls() {
      localObjectUrls.splice(0).forEach((url) => URL.revokeObjectURL(url));
    }

    function resetSlides() {
      slides = [];
      slidePointer = 0;
      lastSlideIndex = 0;
      imageMeta.length = 0;
      metaPromises.length = 0;
    }

    function ensureMeta(index) {
      if (imageMeta[index]) return Promise.resolve(imageMeta[index]);
      if (metaPromises[index]) return metaPromises[index];

      const src = images[index]?.src;
      if (!src) return Promise.resolve({ width: 0, height: 0 });

      const promise = new Promise((resolve) => {
        const img = new Image();
        img.onload = () => {
          const meta = { width: img.naturalWidth || 0, height: img.naturalHeight || 0 };
          imageMeta[index] = meta;
          resolve(meta);
        };
        img.onerror = () => {
          const meta = { width: 0, height: 0 };
          imageMeta[index] = meta;
          resolve(meta);
        };
        img.src = src;
      });

      metaPromises[index] = promise;
      return promise;
    }

    function shouldAutoPair(meta) {
      if (!meta) return false;
      const { width, height } = meta;
      if (!width || !height) return false;
      const aspect = width / height;
      // Portrait/narrow pages become double spread, landscape stays single.
      return aspect <= 0.8;
    }

    async function rebuildSlides(targetIndex = 0) {
      slides = [];
      slidePointer = 0;
      if (!images.length) return;

      let i = 0;
      while (i < images.length) {
        let count = 1;
        if (slideMode === "double") {
          count = Math.min(2, images.length - i);
        } else if (slideMode === "triple") {
          count = Math.min(3, images.length - i);
        } else if (slideMode === "single") {
          count = 1;
        } else {
          const meta = await ensureMeta(i);
          const autoPair = shouldAutoPair(meta);
          count = autoPair && i + 1 < images.length ? 2 : 1;
        }
        slides.push({ start: i, count });
        i += count;
      }

      slidePointer = findSlidePointer(targetIndex);
    }

    function findSlidePointer(targetIndex) {
      const found = slides.findIndex(
        (slide) => targetIndex >= slide.start && targetIndex < slide.start + slide.count
      );
      return found >= 0 ? found : 0;
    }

    function renderSlideImages(indices) {
      modalStage.innerHTML = "";
      modalStage.classList.toggle("single", indices.length === 1);
      modalStage.classList.toggle("triple", indices.length === 3);
      indices.forEach((idx) => {
        const item = images[idx];
        const img = document.createElement("img");
        img.className = "modal-img";
        img.src = item.src;
        img.alt = item.name;
        modalStage.appendChild(img);
      });
    }

    function deriveFolderName(files) {
      if (!files.length) return "";
      const relPath = files[0].webkitRelativePath || files[0].name;
      const parts = relPath.split("/");
      return parts.length > 1 ? parts[0] : relPath;
    }

    function bookNameFromFile(file, fallbackFolder) {
      const relPath = file.webkitRelativePath || file.name;
      const parts = relPath.split("/");
      return parts.length > 1 ? parts[0] : fallbackFolder || relPath || "未命名";
    }

    function buildBooks(fileList, fallbackFolder) {
      const groups = new Map();
      Array.from(fileList).forEach((file) => {
        const book = bookNameFromFile(file, fallbackFolder);
        if (!groups.has(book)) groups.set(book, []);
        groups.get(book).push(file);
      });

      return Array.from(groups.entries())
        .sort((a, b) => a[0].localeCompare(b[0], undefined, { numeric: true, sensitivity: "base" }))
        .map(([name, files]) => ({ name, files }));
    }

    function mapFilesToImages(fileArray) {
      return fileArray.map((file) => {
        const url = URL.createObjectURL(file);
        localObjectUrls.push(url);
        return {
          name: file.webkitRelativePath || file.name,
          src: url,
        };
      }).sort(sortByName);
    }

    function setActiveBook(index, sourceKey, defaultFolderName, resumeSlide, resumeSlideIndex) {
      if (!books.length) return;
      const total = books.length;
      currentBookIndex = ((index % total) + total) % total;
      const book = books[currentBookIndex];
      if (sourceKey) bookSourceKey = sourceKey;
      if (defaultFolderName) lastDefaultFolderName = defaultFolderName;

      cleanupLocalUrls();
      resetSlides();
      images = loadBookItems(book);
      const fallbackName = lastDefaultFolderName || i18n.t("folderLabelDefault");
      const activeName = book.name || fallbackName;
      folderLabel.textContent = activeName;
      emptyEl.style.display = images.length ? "none" : "block";
      if (images.length) {
        setStatus("statusCount", {
          sourceKey: bookSourceKey,
          images: images.length,
          bookIndex: currentBookIndex + 1,
          bookTotal: total,
        });
      } else {
        setStatus("statusPickFolder");
      }
      const initialIndexRaw = typeof resumeSlideIndex === "number" ? resumeSlideIndex : 0;
      const initialIndex = Math.min(Math.max(0, initialIndexRaw), Math.max(0, images.length - 1));
      const initialPage = Math.max(1, Math.floor(initialIndex / PAGE_SIZE) + 1);
      renderPage(initialPage);
      updateBookControls();
      renderBookList();
      updateSlideProgressBar();
      updateStatusText();

      if (resumeSlide && modalEl.classList.contains("active")) {
        startSlideshow(initialIndex);
      }
    }

    function updateBookControls() {
      const total = books.length || 0;
      const current = total ? currentBookIndex + 1 : 0;
      bookInfoEl.textContent = i18n.t("bookInfo", { current, total });
      const disabled = total <= 1;
      prevBookBtn.disabled = disabled;
      nextBookBtn.disabled = disabled;
      if (prevBookModalBtn) prevBookModalBtn.disabled = disabled;
      if (nextBookModalBtn) nextBookModalBtn.disabled = disabled;
    }

    function moveBook(delta) {
      if (!books.length || books.length <= 1) return;
      const targetIndex = currentBookIndex + delta;
      const resumeSlide = modalEl.classList.contains("active");
      setActiveBook(
        targetIndex,
        bookSourceKey,
        books[targetIndex]?.name,
        resumeSlide,
        0
      );
    }

    function toggleCollapse(el) {
      if (!el) return;
      el.classList.toggle("open");
      if (el.classList.contains("open")) {
        const panel = el.querySelector(".collapse-panel");
        scrollActiveBookIntoView(panel);
      }
    }

    function renderBookList() {
      const containers = [
        { root: bookListEl, collapse: bookCollapseEl },
        { root: bookListModalEl, collapse: bookCollapseModalEl },
      ];
      containers.forEach(({ root }) => {
        if (!root) return;
        root.innerHTML = "";
        if (!books.length) {
          const empty = document.createElement("div");
          empty.className = "hint";
          empty.textContent = i18n.t("bookListEmpty");
          root.appendChild(empty);
          return;
        }
        const frag = document.createDocumentFragment();
        books.forEach((book, idx) => {
          const btn = document.createElement("button");
          btn.className = "book-btn";
          btn.textContent = `${idx + 1}. ${book.name}`;
          if (idx === currentBookIndex) {
            btn.classList.add("active");
          }
          btn.addEventListener("click", (e) => {
            e.stopPropagation();
            const resumeSlide = modalEl.classList.contains("active");
            setActiveBook(idx, bookSourceKey, book.name, resumeSlide, resumeSlide ? 0 : undefined);
          });
          frag.appendChild(btn);
        });
        root.appendChild(frag);
        scrollActiveBookIntoView(root);
      });
    }

    function isImageFile(name) {
      return /\.(png|jpe?g)$/i.test(name);
    }

    function sortByName(a, b) {
      return a.name.localeCompare(b.name, undefined, { numeric: true, sensitivity: "base" });
    }

    function loadBookItems(book) {
      if (!book) return [];
      if (book.files && book.files.length) {
        return mapFilesToImages(book.files);
      }
      if (book.serverNames && book.serverNames.length) {
        return book.serverNames.map((name) => ({
          name,
          src: `/images/${encodeURIComponent(name)}`,
        }));
      }
      if (book.items) return book.items;
      return [];
    }

    function scrollActiveBookIntoView(root) {
      if (!root) return;
      const activeBtn = root.querySelector(".book-btn.active");
      if (activeBtn && typeof activeBtn.scrollIntoView === "function") {
        activeBtn.scrollIntoView({ block: "nearest" });
      }
    }

    function handleLocalFiles(fileList, sourceKey) {
      const resumeSlide = modalEl.classList.contains("active");
      const files = Array.from(fileList || []);
      const imageFiles = files.filter((file) => isImageFile(file.name));
      if (!imageFiles.length) {
        setStatus("statusNoImages");
        emptyEl.style.display = "block";
        books = [];
        currentBookIndex = 0;
        updateBookControls();
        renderBookList();
        return;
      }

      cleanupLocalUrls();
      const folderName = deriveFolderName(imageFiles);
      bookSourceKey = sourceKey || "local";
      lastDefaultFolderName = folderName || i18n.t("folderLabelDefault");
      const bookGroups = buildBooks(imageFiles, folderName);
      books = bookGroups.map(({ name, files: groupFiles }) => ({
        name,
        files: groupFiles,
      }));
      currentBookIndex = Math.max(
        0,
        books.findIndex((book) => book.name === folderName)
      );
      setActiveBook(
        currentBookIndex,
        bookSourceKey,
        folderName,
        resumeSlide,
        resumeSlide ? 0 : undefined
      );
    }

    async function handleDropEvent(event, sourceKey = "drop") {
      if (!isFileDrag(event)) return;
      event.preventDefault();
      event.stopPropagation();
      folderDropZone.classList.remove("dragover");
      const files = await extractFilesFromDataTransfer(event.dataTransfer);
      if (!files.length) {
        setStatus("statusNoDrop");
        return;
      }
      handleLocalFiles(files, sourceKey);
    }

    function entryToFiles(entry) {
      return new Promise((resolve) => {
        if (entry.isFile) {
          entry.file(
            (file) => {
              const fullPath = entry.fullPath || file.name;
              if (!file.webkitRelativePath && fullPath) {
                Object.defineProperty(file, "webkitRelativePath", {
                  value: fullPath.replace(/^\//, ""),
                  configurable: true,
                });
              }
              resolve([file]);
            },
            () => resolve([])
          );
        } else if (entry.isDirectory) {
          const reader = entry.createReader();
          const entries = [];
          const readEntries = () => {
            reader.readEntries(
              (batch) => {
                if (!batch.length) {
                  Promise.all(entries.map((ent) => entryToFiles(ent))).then((all) =>
                    resolve(all.flat())
                  );
                  return;
                }
                entries.push(...batch);
                readEntries();
              },
              () => resolve([])
            );
          };
          readEntries();
        } else {
          resolve([]);
        }
      });
    }

    async function extractFilesFromDataTransfer(dataTransfer) {
      if (!dataTransfer) return [];
      const items = Array.from(dataTransfer.items || []);
      const entryPromises = items
        .map((item) => (typeof item.webkitGetAsEntry === "function" ? item.webkitGetAsEntry() : null))
        .filter(Boolean)
        .map((entry) => entryToFiles(entry));

      if (entryPromises.length) {
        const nested = await Promise.all(entryPromises);
        return nested.flat();
      }

      return Array.from(dataTransfer.files || []);
    }

    applyLanguageText();
    setWidth(widthSlider.value);
    loadImagesFromServer();
    syncSlideModeSelectors();
  </script>
